---
layout: article
title: Segment Trees
---

<div class="section">
  <h2>Problem:</h2>

  <p class="firstPara">Given a list <em>xs</em>, answer a large number
    of questions of the form, <strong>what is the accumulation of the elements
    whose indices are in the range [l, u]</strong>?.</p>
</div>

<div class="section">
  <h2>Observations:</h2>

  <p class="firstPara">Notice that we have only two requirements for
  the elements of <em>xs</em>:</p>

  <ul>
    <li>we must be able to accumulate them; and</li>
    <li>the neutral element, <em>e</em>, exists (<em>e</em> is the
    result of queries on empty intervals).</li>
  </ul>

  <p>These two suggest that the elements are <strong>Monoid</strong>s.</p>

  <p>Strictly speaking, the accumulation function need not be
    associative, but, if it is, we can build a <strong>segment
    trees</strong> from the list.</p>
</div>

<div class="section">
  <h2>The Naive Solution:</h2>

  <p class="firstPara">Our first solution simply <em>mconcat</em>s the
    interval's elements.</p>

{% highlight haskell %}
queryInterval :: (Monoid a) => [a] -> (Int, Int) -> a
queryInterval xs (l, u) = mconcat . take (u-l+1) . drop l $ xs
{% endhighlight %}

  <p>The <em>queryInterval</em> function requires no additional space
    and takes time proportional to the interval's size.  Therefore,
    the time necessary to query all intervals
    is <strong class="icode">O(n<sup>3</sup>)</strong>.  For large
    values of <em>n</em>, this is clearly unacceptable.  We examine a
    faster algorithm in the next section.</p>
</div>

<div class="section">
  <h2>Simple Segment Trees:</h2>

  <p class="firstPara">A list stores <em>elements</em>; i.e. it stores
  information of the form, <strong>the value of the n<sup>th</sup>
  element is <em>something</em></strong>. A segment tree stores
  intervals; i.e. it stores information of the form, <strong>the
  accumulation of the elements with indices between <em>l</em>
  and <em>u</em> is <em>something</em></strong>.</p>

  <div class="imageBox">
    <img src="SegmentTree/sumTree17.png" alt="the sum interval tree for [1..7]" />
    <span class="caption">The interval tree for [1..7] with addition
    for accumulation</span>
  </div>

</div>

<div id="resources">
  <h2>Resources</h2>

  <ul>
    <li><a href="http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=lowestCommonAncestor#Segment_Trees">
    TopCoder article on RMQ and LCA</a> Even though the article is not
    about segment trees <em>per se</em> (it details a few RMQ and LCA
    algorithms), the section on them is an excellent down-to-earth
    introduction.</li>

    <li><a href="http://en.wikipedia.org/wiki/Segment_tree">Wikipedia
    entry on segment trees</a> The page is a little to obfuscated for
    my tastes, but, for the sake of completeness, the link is
    here.</li>

    <li><a href="http://apfelmus.nfshost.com/monoid-fingertree.html">Monoids
    and Finger Trees</a> apfelmus's article is a good example of how
    to use Monoids to abstract seemingly unrelated operations; he uses
    them to unify priority queue operations.  Similarly, we use
    Monoids to abstract <strong>all</strong> valid accumulation
    operations on intervals.</li>
  </ul>
</div>
