---
layout: article
title: Segment Trees
---

<div class="section">
  <h2>Problem:</h2>

  <p class="firstPara">Given a list <em>xs</em>, answer a large
    number of questions of the form "what is the accumulation of the
    elements whose indices belong to the range [l, u]?".</p>
</div>

<div class="section">
  <h2>Observations:</h2>

  <p class="firstPara">First of all, notice that the only
    requirements for the elements of <em>xs</em> is that they can be
    accumulated and that the neutral element, <em>e</em>, exists
    (<em>e</em> is the result of queries on empty intervals).  These
    two conditions suggest constraining the elements of <em>xs</em> to
    those that form <strong>monoids</strong>.  Strictly speaking, the
    accumulation function need not be associative but requiring it
    allows <strong>segment trees</strong> to be constructed.</p>
</div>

<div class="section">
  <h2>The Naive Solution:</h2>

  <p class="firstPara">This solution simply <em>mconcat</em>s the
    interval's elements.</p>

{% highlight haskell %}
queryInterval :: (Monoid a) => [a] -> (Int, Int) -> a
queryInterval xs (l, u) = mconcat . take (u-l+1) . drop l $ xs
{% endhighlight %}

  <p>The <em>queryInterval</em> function requires no additional
    space and takes time proportional to the interval's size.
    Therefore, the time necessary to query all interval would
    be <strong>O(n<sup>3</sup>)</strong>.  For large values
    of <em>n</em>, this is clearly unacceptable.  A faster algorithm
    is presented in the next section.</p>
</div>

<div class="section">
  <h2>Simple Segment Trees:</h2>

  <p class="firstPara">to be continued...</p>

</div>
