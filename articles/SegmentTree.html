---
layout: article
title: Segment Trees
---

<div class="section">
  <h2>Problem:</h2>

  <p class="firstPara">Given a list <em>xs</em>, answer a large
    number of questions of the form "what is the accumulation of the
    elements whose indices belong to the range [l, u]?".</p>
</div>

<div class="section">
  <h2>Observations:</h2>

  <p class="firstPara">First of all, notice that the only
    requirements for the elements of <em>xs</em> is that they can be
    accumulated and that the neutral element, <em>e</em>, exists
    (<em>e</em> is the result of queries on empty intervals).  These
    two conditions suggest constraining the elements of <em>xs</em> to
    those that form <strong>monoids</strong>.  Strictly speaking, the
    accumulation function need not be associative but requiring it
    allows <strong>segment trees</strong> to be constructed.</p>
</div>

<div class="section">
  <h2>The Naive Solution:</h2>

  <p class="firstPara">This solution simply <em>mconcat</em>s the
    interval's elements.</p>

  <pre class="code"><span class='hs-definition'>queryInterval</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
    <span class='hs-definition'>queryInterval</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>u</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mconcat</span> <span class='hs-varop'>.</span> <span class='hs-varid'>take</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-comment'>-</span><span class='hs-varid'>l</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>drop</span> <span class='hs-varid'>l</span> <span class='hs-varop'>$</span> <span class='hs-varid'>xs</span>
  </pre>

  <p>The <em>queryInterval</em> function requires no additional
    space and takes time proportional to the interval's size.
    Therefore, the time necessary to query all interval would
    be <strong>O(n<sup>3</sup>)</strong>.  For large values
    of <em>n</em>, this is clearly unacceptable.  A faster algorithm
    is presented in the next section.</p>
</div>

<div class="section">
  <h2>Simple Segment Trees:</h2>

  <p class="firstPara">to be continued...</p>
</div>
